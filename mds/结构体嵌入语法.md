```go
type BodyLogWriter struct {
gin.ResponseWriter               // 嵌入gin框架ResponseWriter
body               *bytes.Buffer // 记录用的response
}

```

我很奇怪为什么可以使用原始类型gin.ResponseWriter直接作为新结构体的字段呢？

这是 Go 的「**结构体嵌入（embedding）**」语法，不是把“原始类型”当字段，而是把**接口类型**（`gin.ResponseWriter` 是 interface）**嵌入**到新结构体里，效果 ≈ 自动实现接口 + 方法升级。

---

### 1. `gin.ResponseWriter` 本质是 **interface**
```go
type ResponseWriter interface {
	http.ResponseWriter
	http.Hijacker
	http.Flusher
	http.CloseNotifier
	// ... 更多 Gin 自己的方法
}
```

---

### 2. 嵌入后发生了什么
```go
type BodyLogWriter struct {
	gin.ResponseWriter               // 嵌入接口
	body *bytes.Buffer
}
```
- 编译器会为 `BodyLogWriter` **生成同名字段**（名字就是类型名，首字母小写）。
- 所有 `gin.ResponseWriter` 的方法集被**自动提升到外层**。  
  因此：
  ```go
  blw.Status()              // 直接可用
  blw.Header().Set("k","v") // 直接可用
  ```
  不需要再写 `.ResponseWriter.Status()`。

---

### 3. 方法“透传” vs. 重写
- **未重写**的方法 → 自动调用嵌入接口里的实现（**透传**）。
- **重写**的方法（例如 `Write`）→ 使用你自己的实现，**嵌入字段被“遮盖”**。

---

### 4. 为什么这样做
- **少写样板代码**：不用把 20 个方法全部代理一遍。
- **接口自动满足**：`BodyLogWriter` 现在**就是** `gin.ResponseWriter`，可以赋值给 `c.Writer`。
- **“装饰器”模式**：在 IO 流、中间件里非常常见（日志、压缩、限流）。

---

### 🔍 一句话
嵌入接口 ≠ 普通字段，而是  
“**把别人的整个方法集搬到我身上，我想改的就覆盖，其余自动透传**”——  
因此我们只写 `Write` 就能做出“记录 + 原样写回”的 ResponseWriter 装饰器。