# 国际化功能说明

## 概述

项目已实现国际化（i18n）功能，实现了日志消息和API响应消息的分离：
- **日志消息**：使用英文，便于国际化团队和日志分析工具理解
- **API响应消息**：使用中文（默认），可根据客户端需求扩展为多语言

## 设计理念

### 为什么日志使用英文？

1. **国际化标准**：英文是国际通用的技术交流语言
2. **日志分析**：大多数日志分析工具和监控系统默认支持英文
3. **团队协作**：跨国家/地区的开发团队更容易理解英文日志
4. **工具支持**：日志查询、过滤、聚合等功能对英文支持更好

### 为什么API响应使用中文？

1. **用户体验**：中文用户更易理解中文提示
2. **业务需求**：根据业务场景可以灵活切换语言
3. **可扩展性**：通过 `Accept-Language` 头支持多语言（未来扩展）

## i18n 包介绍

### 包位置

```
internal/i18n/i18n.go
```

### 核心概念

#### 1. 语言类型（Language）

```go
type Language string

const (
    LanguageEn Language = "en"  // 英语
    LanguageZh Language = "zh"  // 中文
)
```

#### 2. 消息键类型（MessageKey）

```go
type MessageKey string
```

所有消息通过唯一的键（Key）来标识，使用点号分隔的层级结构：

- **日志消息键**：以 `log.` 开头
  - `log.auth.failed.no_token` - 认证失败：未提供令牌
  - `log.request.cost` - 请求处理耗时
  - `log.response.body` - 响应体

- **用户消息键**：以 `user.` 开头
  - `user.create.success` - 创建成功
  - `user.get.success` - 获取成功
  - `user.error.bad_request` - 请求参数错误

#### 3. 消息映射表

```go
var messages = map[MessageKey]map[Language]string{
    LogAuthFailedNoToken: {
        LanguageEn: "Authentication failed: no token provided",
        LanguageZh: "认证失败：未提供认证令牌",
    },
    UserCreateSuccess: {
        LanguageZh: "创建成功",
        LanguageEn: "Created successfully",
    },
    // ...
}
```

消息存储在内存中的映射表中，支持快速查找和多语言翻译。

### 核心函数

#### 1. LogMessage - 获取日志消息（英文）

```go
func LogMessage(key MessageKey) string
```

**功能**：获取日志消息，始终返回英文版本。

**使用场景**：所有日志记录（Info、Warn、Error、Debug）。

**示例**：
```go
logger.Log.Warn(i18n.LogMessage(i18n.LogAuthFailedNoToken),
    zap.String("request_id", requestID),
    zap.String("path", path),
)
// 输出: "Authentication failed: no token provided"
```

#### 2. UserMessage - 获取用户消息（默认中文）

```go
func UserMessage(key MessageKey, lang ...Language) string
```

**功能**：获取用户消息，默认返回中文，可通过参数指定语言。

**参数**：
- `key`: 消息键
- `lang`: 可选的语言参数（默认 `LanguageZh`）

**使用场景**：所有API响应消息。

**示例**：
```go
// 默认中文
response.Success(c, i18n.UserMessage(i18n.UserCreateSuccess), user)
// 响应: {"message": "创建成功", ...}

// 指定英文
response.Success(c, i18n.UserMessage(i18n.UserCreateSuccess, i18n.LanguageEn), user)
// 响应: {"message": "Created successfully", ...}
```

#### 3. UserMessagef - 格式化用户消息

```go
func UserMessagef(key MessageKey, args ...interface{}) string
```

**功能**：获取格式化的用户消息（类似 `fmt.Sprintf`）。

**使用场景**：需要动态参数的响应消息。

**示例**（未来扩展）：
```go
msg := i18n.UserMessagef(i18n.UserErrorInvalidID, userID)
// 返回: "无效的用户ID: 123"
```

## 消息键列表

### 日志消息键（英文）

| 消息键 | 英文 | 中文 | 使用场景 |
|--------|------|------|----------|
| `log.auth.failed.no_token` | Authentication failed: no token provided | 认证失败：未提供认证令牌 | 认证中间件 |
| `log.auth.failed.invalid_format` | Authentication failed: invalid token format | 认证失败：令牌格式错误 | 认证中间件 |
| `log.auth.failed.invalid` | Authentication failed: token validation failed | 认证失败：令牌验证失败 | 认证中间件 |
| `log.auth.success` | Authentication successful | 认证成功 | 认证中间件 |
| `log.request.cost` | Request processing time | 请求处理耗时 | 请求统计中间件 |
| `log.response.body` | Response body | 响应体 | 响应体日志中间件 |
| `log.panic.recovered` | Panic recovered | Panic已恢复 | 恢复中间件 |
| `log.internal.error` | Internal server error | 内部服务器错误 | 错误处理 |

### 用户消息键（中文，API响应）

| 消息键 | 中文 | 英文 | 使用场景 |
|--------|------|------|----------|
| `user.auth.no_token` | 未提供认证令牌 | No authentication token provided | 认证错误 |
| `user.auth.invalid_format` | 认证令牌格式错误 | Invalid authentication token format | 认证错误 |
| `user.auth.invalid` | 无效的认证令牌 | Invalid authentication token | 认证错误 |
| `user.create.success` | 创建成功 | Created successfully | 用户创建 |
| `user.get.success` | 获取成功 | Retrieved successfully | 用户查询 |
| `user.get_all.success` | 获取成功 | Retrieved successfully | 用户列表 |
| `user.update.success` | 更新成功 | Updated successfully | 用户更新 |
| `user.delete.success` | 删除成功 | Deleted successfully | 用户删除 |
| `user.login.success` | 登录成功 | Login successful | 用户登录 |
| `user.error.bad_request` | 请求参数错误 | Bad request | 参数验证错误 |
| `user.error.invalid_id` | 无效的用户ID: %s | Invalid user ID: %s | ID格式错误 |
| `user.error.json_format` | JSON格式错误 | Invalid JSON format | JSON解析错误 |
| `user.error.internal` | 内部服务器错误 | Internal server error | 服务器错误 |
| `user.health.check_success` | 服务运行正常 | Service is running normally | 健康检查 |

## 使用方式

### 1. 在中间件中使用

#### 认证中间件示例

```go
// internal/api/middleware/auth.go
import "gin/internal/i18n"

func AuthMiddleware(jwtConfig *auth.JWTConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        
        if authHeader == "" {
            // 日志使用英文
            logger.Log.Warn(i18n.LogMessage(i18n.LogAuthFailedNoToken),
                zap.String("request_id", requestID),
            )
            // API响应使用中文
            response.Unauthorized(c, i18n.UserMessage(i18n.UserAuthNoToken), nil)
            c.Abort()
            return
        }
        // ...
    }
}
```

#### 请求统计中间件示例

```go
// internal/api/middleware/middleware.go
import "gin/internal/i18n"

func StatCost() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()
        cost := time.Since(start)
        
        // 日志使用英文
        logger.Log.Info(i18n.LogMessage(i18n.LogRequestCost),
            zap.String("path", path),
            zap.Duration("cost", cost),
        )
    }
}
```

### 2. 在Handler中使用

#### 用户处理器示例

```go
// internal/api/handlers/user.go
import "gin/internal/i18n"

func (h *UserHandler) CreateUser() gin.HandlerFunc {
    return func(c *gin.Context) {
        user, err := h.userService.CreateUser(ctx, &req)
        if err != nil {
            c.Error(err)
            return
        }
        
        // API响应使用中文
        response.Created(c, i18n.UserMessage(i18n.UserCreateSuccess), user)
    }
}
```

#### 错误处理示例

```go
// internal/api/handlers/user.go
func (h *UserHandler) GetUser() gin.HandlerFunc {
    return func(c *gin.Context) {
        idStr := c.Param("id")
        id, err := strconv.ParseInt(idStr, 10, 64)
        if err != nil {
            // 格式化消息（包含动态参数）
            msg := fmt.Sprintf(i18n.UserMessage(i18n.UserErrorInvalidID), idStr)
            c.Error(errors.NewBadRequestError(msg, err))
            return
        }
        // ...
    }
}
```

### 3. 在错误处理中使用

```go
// internal/errors/errors.go
import "gin/internal/i18n"

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()
        
        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            
            if _, ok := err.(validator.ValidationErrors); ok {
                // 使用国际化消息
                respondError(c, NewBadRequestError(
                    i18n.UserMessage(i18n.UserErrorBadRequest), 
                    err,
                ))
            } else if _, ok := err.(*json.SyntaxError); ok {
                respondError(c, NewBadRequestError(
                    i18n.UserMessage(i18n.UserErrorJSONFormat), 
                    err,
                ))
            }
            // ...
        }
    }
}
```

## 添加新消息

### 步骤

1. **定义消息键常量**

在 `internal/i18n/i18n.go` 中添加：

```go
const (
    // 新增日志消息键
    LogNewFeature MessageKey = "log.feature.new"
    
    // 新增用户消息键
    UserNewFeatureSuccess MessageKey = "user.feature.new_success"
)
```

2. **添加到消息映射表**

```go
var messages = map[MessageKey]map[Language]string{
    // 日志消息（英文）
    LogNewFeature: {
        LanguageEn: "New feature executed",
        LanguageZh: "新功能已执行",
    },
    
    // 用户消息（中文）
    UserNewFeatureSuccess: {
        LanguageZh: "新功能执行成功",
        LanguageEn: "New feature executed successfully",
    },
}
```

3. **在代码中使用**

```go
// 日志使用
logger.Log.Info(i18n.LogMessage(i18n.LogNewFeature), ...)

// API响应使用
response.Success(c, i18n.UserMessage(i18n.UserNewFeatureSuccess), data)
```

## 最佳实践

### 1. 消息键命名规范

- 使用点号分隔的层级结构
- 日志消息以 `log.` 开头
- 用户消息以 `user.` 开头
- 使用小写字母和下划线

**示例**：
```go
LogAuthFailedNoToken     // ✅ 正确
log.auth.failed.no_token // ❌ 这是键的值，不是常量名

UserCreateSuccess        // ✅ 正确
user.create.success      // ❌ 这是键的值，不是常量名
```

### 2. 日志消息规范

- 所有日志消息**必须**使用 `i18n.LogMessage()`
- 始终返回英文，便于日志分析
- 保持消息简洁明了

```go
// ✅ 正确
logger.Log.Warn(i18n.LogMessage(i18n.LogAuthFailedNoToken), ...)

// ❌ 错误：直接使用中文
logger.Log.Warn("认证失败：未提供认证令牌", ...)
```

### 3. API响应消息规范

- 所有API响应消息**必须**使用 `i18n.UserMessage()`
- 默认使用中文（`LanguageZh`）
- 支持未来扩展为多语言

```go
// ✅ 正确：默认中文
response.Success(c, i18n.UserMessage(i18n.UserCreateSuccess), data)

// ✅ 正确：指定语言（未来扩展）
response.Success(c, i18n.UserMessage(i18n.UserCreateSuccess, i18n.LanguageEn), data)

// ❌ 错误：直接硬编码中文
response.Success(c, "创建成功", data)
```

### 4. 格式化消息

对于需要动态参数的消息，使用 `fmt.Sprintf` 格式化：

```go
// ✅ 正确
msg := fmt.Sprintf(i18n.UserMessage(i18n.UserErrorInvalidID), idStr)
c.Error(errors.NewBadRequestError(msg, err))

// ❌ 错误：直接在消息中包含参数
c.Error(errors.NewBadRequestError(fmt.Sprintf("无效的用户ID: %s", idStr), err))
```

## 扩展支持

### 未来扩展：根据请求头自动选择语言

可以通过中间件根据 `Accept-Language` 请求头自动选择语言：

```go
// 伪代码示例
func LanguageMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        lang := c.GetHeader("Accept-Language")
        if strings.Contains(lang, "en") {
            c.Set("language", i18n.LanguageEn)
        } else {
            c.Set("language", i18n.LanguageZh)
        }
        c.Next()
    }
}

// 在Handler中使用
func (h *UserHandler) CreateUser() gin.HandlerFunc {
    return func(c *gin.Context) {
        lang, _ := c.Get("language")
        response.Success(c, 
            i18n.UserMessage(i18n.UserCreateSuccess, lang.(i18n.Language)), 
            data,
        )
    }
}
```

### 从配置文件加载

可以将消息存储在配置文件中，支持热更新：

```yaml
# i18n/messages.yaml
messages:
  log.auth.failed.no_token:
    en: "Authentication failed: no token provided"
    zh: "认证失败：未提供认证令牌"
  
  user.create.success:
    zh: "创建成功"
    en: "Created successfully"
```

## 测试

### 单元测试

```go
func TestLogMessage(t *testing.T) {
    msg := i18n.LogMessage(i18n.LogAuthFailedNoToken)
    assert.Equal(t, "Authentication failed: no token provided", msg)
}

func TestUserMessage(t *testing.T) {
    // 默认中文
    msg := i18n.UserMessage(i18n.UserCreateSuccess)
    assert.Equal(t, "创建成功", msg)
    
    // 指定英文
    msg = i18n.UserMessage(i18n.UserCreateSuccess, i18n.LanguageEn)
    assert.Equal(t, "Created successfully", msg)
}
```

### 集成测试

所有API测试已验证国际化功能正常工作：
- ✅ 日志消息为英文
- ✅ API响应消息为中文
- ✅ 所有测试通过

## 文件清单

### 核心文件

- `internal/i18n/i18n.go` - 国际化包核心实现

### 使用国际化的文件

- `internal/api/middleware/auth.go` - 认证中间件
- `internal/api/middleware/middleware.go` - 请求统计中间件
- `internal/api/handlers/user.go` - 用户处理器
- `internal/api/handlers/health.go` - 健康检查处理器
- `internal/errors/errors.go` - 错误处理中间件
- `internal/middleware/recovery.go` - 恢复中间件

## 总结

国际化功能实现了日志消息和API响应消息的分离：

1. **日志消息**：使用 `i18n.LogMessage()` 获取英文消息
2. **API响应**：使用 `i18n.UserMessage()` 获取中文消息（默认）
3. **类型安全**：使用 `MessageKey` 类型确保消息键正确
4. **易于维护**：所有消息集中在 `i18n` 包中管理
5. **可扩展性**：支持添加新语言和消息键

这符合企业级开发标准，使系统更加国际化、专业化和易于维护。
