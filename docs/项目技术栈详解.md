# 项目技术栈详解

本文档详细讲解项目中使用的各个库和组件，帮助你理解整个项目的架构。

## 目录
1. [Cobra - 命令行框架](#1-cobra---命令行框架)
2. [Zap - 结构化日志库](#2-zap---结构化日志库)
3. [Gin - Web框架](#3-gin---web框架)
4. [errgroup - 并发控制](#4-errgroup---并发控制)
5. [依赖注入容器](#5-依赖注入容器)
6. [优雅关闭机制](#6-优雅关闭机制)
7. [Prometheus - 指标监控](#7-prometheus---指标监控)

---

## 1. Cobra - 命令行框架

### 什么是 Cobra？
Cobra 是 Go 语言最流行的命令行框架，很多知名项目都在使用（如 Docker、Kubernetes、Hugo 等）。

### 为什么使用 Cobra？
- **统一命令接口**：让程序可以通过命令行参数控制行为
- **子命令支持**：可以创建多个子命令（如 `server`、`ds`、`examples`）
- **自动生成帮助信息**：`--help` 自动显示命令说明

### 项目中的使用

#### 1.1 根命令 (`cmd/root.go`)
```go
var rootCmd = &cobra.Command{
    Use:   "gin",           // 命令名称
    Short: "Gin API服务与Go语法学习工具",  // 简短描述
    Long:  `详细描述...`,    // 详细描述
}
```

#### 1.2 子命令 (`cmd/commands/server.go`)
```go
var ServerCmd = &cobra.Command{
    Use:   "server",        // 子命令名称
    Short: "运行Gin API服务",
    Run: func(cmd *cobra.Command, args []string) {
        server.Main()  // 执行实际的业务逻辑
    },
}
```

#### 1.3 注册子命令
```go
rootCmd.AddCommand(commands.ServerCmd)
```

### 使用示例
```bash
# 运行服务器
go run main.go server

# 查看帮助
go run main.go --help
go run main.go server --help
```

### 核心概念
- **Command**：一个命令对象，包含执行逻辑
- **Use**：命令的使用方式（名称）
- **Run**：命令执行时调用的函数
- **AddCommand**：添加子命令

---

## 2. Zap - 结构化日志库

### 什么是 Zap？
Zap 是 Uber 开源的**高性能结构化日志库**，比标准库的 `log` 包快得多。

### 为什么使用 Zap？
- **性能高**：比标准库快 4-10 倍
- **结构化日志**：输出 JSON 格式，便于日志分析
- **日志级别**：支持 Debug、Info、Warn、Error 等
- **字段丰富**：可以添加任意字段（如用户ID、请求ID等）

### 项目中的使用 (`internal/logger/logger.go`)

#### 2.1 初始化日志器
```go
func InitLogger(cfg *config.LoggingConfig) *zap.Logger {
    // 1. 配置日志级别
    var level zapcore.Level
    switch cfg.Level {
    case "debug": level = zapcore.DebugLevel
    case "info":  level = zapcore.InfoLevel
    // ...
    }
    
    // 2. 配置编码器（决定日志格式）
    encoderConfig := zapcore.EncoderConfig{
        TimeKey:    "timestamp",  // 时间字段名
        LevelKey:   "level",      // 级别字段名
        MessageKey: "message",    // 消息字段名
        // ...
    }
    
    // 3. 创建 Core（核心组件）
    core := zapcore.NewCore(
        zapcore.NewJSONEncoder(encoderConfig),  // JSON编码器
        zapcore.AddSync(os.Stdout),             // 输出到标准输出
        zap.NewAtomicLevelAt(level),            // 日志级别
    )
    
    // 4. 构建 Logger
    logger := zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
    return logger
}
```

#### 2.2 使用日志器
```go
log.Info("服务器启动", 
    zap.String("addr", addr),        // 添加字符串字段
    zap.Int("port", 8080),           // 添加整数字段
)

log.Error("数据库初始化失败", 
    zap.Error(err),                  // 添加错误对象
)
```

#### 2.3 日志输出示例
```json
{
  "timestamp": "2024-01-01T10:00:00Z",
  "level": "info",
  "message": "服务器启动",
  "addr": ":8080",
  "caller": "server/main.go:97"
}
```

### 核心概念
- **Logger**：日志器对象
- **Core**：核心组件，决定如何编码和输出
- **Encoder**：编码器，决定日志格式（JSON/Console）
- **Level**：日志级别（Debug < Info < Warn < Error）

---

## 3. Gin - Web框架

### 什么是 Gin？
Gin 是 Go 语言最流行的 Web 框架，性能高、API 简洁。

### 为什么使用 Gin？
- **性能高**：基于 `httprouter`，路由性能极佳
- **API 简洁**：代码易读易写
- **中间件支持**：可以轻松添加功能（日志、认证、限流等）
- **JSON 绑定**：自动将请求数据绑定到结构体

### 项目中的使用

#### 3.1 创建路由引擎 (`internal/api/routes.go`)
```go
router := gin.Default()  // 创建默认引擎（包含日志和恢复中间件）
```

#### 3.2 注册路由
```go
// GET 请求
router.GET("/hello", handlers.HelloHandler())

// POST 请求
router.POST("/loginJSON", handlers.LoginJSONHandler())

// 路径参数
router.GET("/user/get/:username/:address", handlers.UserGetHandler())

// 路由组
userGroup := router.Group("/user", middleware.StatCost())
{
    userGroup.GET("/index", handlers.GetUser())
}
```

#### 3.3 中间件
```go
// 全局中间件（所有路由都会经过）
router.Use(apimiddleware.GinBodyLogMiddleware())  // 记录请求体
router.Use(errors.ErrorHandler())                  // 统一错误处理
router.Use(metrics.PrometheusMiddleware())         // 指标收集
router.Use(appmiddleware.Recovery())              // 异常恢复

// 路由组中间件（只对该组生效）
userGroup := router.Group("/user", middleware.StatCost())
```

#### 3.4 中间件示例 (`internal/api/middleware/middleware.go`)
```go
// 记录接口耗时的中间件
func StatCost() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()  // 执行下一个中间件或处理函数
        cost := time.Since(start)
        fmt.Printf("耗时: %v\n", cost)
    }
}
```

### 请求处理流程
```
请求 → 中间件1 → 中间件2 → ... → 处理函数 → 响应
                ↑
              c.Next() 在这里调用下一个
```

### 核心概念
- **Engine**：Gin 引擎，管理路由和中间件
- **Router**：路由器，注册路由规则
- **HandlerFunc**：处理函数，处理请求
- **Middleware**：中间件，在请求处理前后执行
- **Context**：请求上下文，包含请求和响应信息

---

## 4. errgroup - 并发控制

### 什么是 errgroup？
`errgroup` 是 Go 官方提供的并发控制工具，用于管理多个 goroutine 的执行。

### 为什么使用 errgroup？
- **并发执行**：可以同时启动多个任务
- **错误收集**：任何一个任务失败，整个组都会停止
- **上下文取消**：可以统一取消所有任务

### 项目中的使用 (`cmd/server/main.go`)

#### 4.1 创建 errgroup
```go
g, ctx := errgroup.WithContext(context.Background())
// g: 用于管理 goroutine
// ctx: 上下文，用于取消所有任务
```

#### 4.2 启动多个服务器
```go
for _, s := range servers {
    srv := &http.Server{...}
    
    // 启动服务器（在一个 goroutine 中）
    g.Go(func() error {
        return srv.ListenAndServe()
    })
    
    // 优雅关闭（在另一个 goroutine 中）
    g.Go(func() error {
        <-ctx.Done()  // 等待上下文取消
        return srv.Shutdown(shutdownCtx)
    })
}
```

#### 4.3 信号监听
```go
g.Go(func() error {
    c := make(chan os.Signal, 1)
    signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
    sig := <-c  // 收到信号
    return fmt.Errorf("收到信号: %v", sig)  // 返回错误，触发 ctx 取消
})
```

#### 4.4 等待所有任务完成
```go
if err := g.Wait(); err != nil {
    log.Error("服务器异常退出", zap.Error(err))
}
```

### 执行流程
```
启动 errgroup
  ├─→ goroutine 1: 服务器1监听 (:8080)
  ├─→ goroutine 2: 服务器1关闭监听
  ├─→ goroutine 3: 服务器2监听 (:8081)
  ├─→ goroutine 4: 服务器2关闭监听
  ├─→ goroutine 5: 服务器3监听 (:8082)
  ├─→ goroutine 6: 服务器3关闭监听
  └─→ goroutine 7: 信号监听 (SIGINT/SIGTERM)
  
当收到信号时：
  1. 信号监听 goroutine 返回错误
  2. ctx 被取消
  3. 所有关闭监听的 goroutine 检测到 ctx.Done()
  4. 执行 Shutdown() 关闭服务器
  5. g.Wait() 返回错误
```

### 核心概念
- **errgroup.Group**：管理一组 goroutine
- **g.Go()**：启动一个 goroutine，如果返回错误，会取消 ctx
- **g.Wait()**：等待所有 goroutine 完成
- **ctx.Done()**：上下文取消信号

---

## 5. 依赖注入容器

### 什么是依赖注入？
依赖注入（DI）是一种设计模式，将依赖关系从代码中分离出来，由外部容器管理。

### 为什么使用依赖注入？
- **解耦**：组件不直接依赖具体实现
- **测试友好**：可以轻松替换依赖（如用 mock 数据库）
- **统一管理**：所有依赖在一个地方管理

### 项目中的实现 (`internal/di/container.go`)

#### 5.1 容器结构
```go
type Container struct {
    services sync.Map  // 线程安全的 Map，存储所有服务
}
```

#### 5.2 单例模式
```go
var (
    container *Container
    once      sync.Once  // 确保只初始化一次
)

func GetContainer() *Container {
    once.Do(func() {
        container = &Container{}
    })
    return container
}
```

#### 5.3 注册服务
```go
// 在 server/main.go 中
db, _ := database.InitDB(cfg.Database.DSN)
di.GetContainer().Register("db", db)  // 注册数据库连接
```

#### 5.4 获取服务
```go
// 在其他地方使用
db, err := di.GetContainer().Get("db")
if err != nil {
    // 服务不存在
}
```

### 使用场景
```go
// 注册阶段（启动时）
container.Register("db", database)
container.Register("logger", logger)
container.Register("cache", cache)

// 使用阶段（运行时）
db := container.MustGet("db").(database.DB)
logger := container.MustGet("logger").(*zap.Logger)
```

### 核心概念
- **Container**：容器，存储所有服务
- **Register**：注册服务到容器
- **Get**：从容器获取服务
- **sync.Map**：线程安全的 Map，支持并发读写

---

## 6. 优雅关闭机制

### 什么是优雅关闭？
优雅关闭是指服务器在收到关闭信号时，不会立即停止，而是：
1. 停止接收新请求
2. 等待正在处理的请求完成
3. 清理资源（关闭数据库连接等）
4. 然后才退出

### 为什么需要优雅关闭？
- **数据安全**：避免正在处理的请求被中断
- **用户体验**：不会突然断开连接
- **资源清理**：确保资源正确释放

### 项目中的实现 (`cmd/server/main.go`)

#### 6.1 信号监听
```go
g.Go(func() error {
    c := make(chan os.Signal, 1)
    signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)  // 监听 Ctrl+C 和 kill 信号
    sig := <-c
    return fmt.Errorf("收到信号: %v", sig)  // 返回错误，触发关闭流程
})
```

#### 6.2 优雅关闭每个服务器
```go
g.Go(func() error {
    <-ctx.Done()  // 等待上下文取消（收到信号时）
    log.Info("正在关闭服务器", zap.String("addr", addr))
    
    // 设置 5 秒超时
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    // 优雅关闭：停止接收新请求，等待现有请求完成
    return srv.Shutdown(shutdownCtx)
})
```

#### 6.3 关闭流程
```
1. 用户按 Ctrl+C 或发送 kill 信号
   ↓
2. 信号监听 goroutine 收到信号，返回错误
   ↓
3. errgroup 的 ctx 被取消
   ↓
4. 所有关闭监听的 goroutine 检测到 ctx.Done()
   ↓
5. 每个服务器执行 Shutdown()：
   - 停止接收新请求
   - 等待现有请求完成（最多 5 秒）
   - 关闭服务器
   ↓
6. 所有 goroutine 完成，程序退出
```

### 核心概念
- **signal.Notify**：注册信号监听
- **SIGINT**：Ctrl+C 信号
- **SIGTERM**：kill 命令发送的信号
- **Shutdown**：优雅关闭服务器
- **WithTimeout**：设置超时，避免无限等待

---

## 7. Prometheus - 指标监控

### 什么是 Prometheus？
Prometheus 是一个开源的监控和告警系统，可以收集应用程序的指标数据。

### 为什么使用 Prometheus？
- **性能监控**：监控请求数量、响应时间等
- **问题诊断**：通过指标快速定位问题
- **可视化**：可以配合 Grafana 展示图表

### 项目中的使用 (`internal/metrics/metrics.go`)

#### 7.1 定义指标
```go
// 请求计数器（记录请求总数）
var requestCount = promauto.NewCounterVec(
    prometheus.CounterOpts{
        Name: "http_requests_total",
        Help: "Total number of HTTP requests",
    },
    []string{"method", "endpoint", "status"},  // 标签：方法、路径、状态码
)

// 请求耗时直方图（记录响应时间分布）
var requestDuration = promauto.NewHistogramVec(
    prometheus.HistogramOpts{
        Name:    "http_request_duration_seconds",
        Help:    "HTTP request duration in seconds",
        Buckets: prometheus.DefBuckets,  // 时间桶
    },
    []string{"method", "endpoint"},
)
```

#### 7.2 中间件收集指标
```go
func PrometheusMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        c.Next()  // 处理请求
        duration := time.Since(start).Seconds()
        
        status := c.Writer.Status()
        // 记录请求计数
        requestCount.WithLabelValues(
            c.Request.Method,    // GET/POST
            c.FullPath(),        // /user/index
            strconv.Itoa(status), // 200/404/500
        ).Inc()
        
        // 记录请求耗时
        requestDuration.WithLabelValues(
            c.Request.Method,
            c.FullPath(),
        ).Observe(duration)
    }
}
```

#### 7.3 暴露指标端点
```go
// 在 routes.go 中
router.GET("/metrics", metrics.MetricsHandler())
```

#### 7.4 查看指标
```bash
# 访问指标端点
curl http://localhost:8080/metrics

# 输出示例
# http_requests_total{method="GET",endpoint="/hello",status="200"} 10
# http_request_duration_seconds_bucket{method="GET",endpoint="/hello",le="0.005"} 8
```

### 核心概念
- **Counter**：计数器，只增不减（如请求总数）
- **Histogram**：直方图，记录数值分布（如响应时间）
- **Label**：标签，用于区分不同的指标（如不同路径的请求）
- **Metrics Endpoint**：指标端点，Prometheus 从这里拉取数据

---

## 总结

### 技术栈关系图
```
main.go (入口)
  ↓
Cobra (命令行框架)
  ↓
server.Main()
  ├─→ Viper (配置管理) ✅ 你已经熟悉
  ├─→ Zap (日志系统)
  ├─→ Database (数据库)
  ├─→ Gin (Web框架)
  │   ├─→ Routes (路由)
  │   ├─→ Middleware (中间件)
  │   │   ├─→ BodyLog (请求日志)
  │   │   ├─→ ErrorHandler (错误处理)
  │   │   ├─→ Prometheus (指标收集)
  │   │   └─→ Recovery (异常恢复)
  │   └─→ Handlers (处理函数)
  ├─→ errgroup (并发控制)
  │   ├─→ 多个 HTTP 服务器
  │   └─→ 信号监听
  └─→ 优雅关闭
```

### 学习建议
1. **Cobra**：理解命令和子命令的概念
2. **Zap**：掌握结构化日志的使用
3. **Gin**：重点学习路由和中间件
4. **errgroup**：理解并发控制和上下文取消
5. **依赖注入**：理解解耦和依赖管理
6. **优雅关闭**：理解信号处理和资源清理
7. **Prometheus**：了解指标收集的基本概念

### 下一步
- 尝试修改日志级别，观察输出变化
- 添加新的路由和处理函数
- 创建自定义中间件
- 查看 `/metrics` 端点的输出
