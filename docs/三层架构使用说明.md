# 三层架构使用说明

## 架构说明

项目已实现企业级三层架构：

```
Handler (控制器层)
  ↓
Service (业务逻辑层)
  ↓
Repository (数据访问层)
  ↓
Database (数据库层)
```

## 目录结构

```
internal/
├── models/              # 数据模型
│   └── user.go         # 用户模型
├── repository/         # 数据访问层
│   └── user_repository.go
├── service/            # 业务逻辑层
│   └── user_service.go
└── api/
    └── handlers/       # 控制器层
        └── user.go
```

## API 端点

### 用户相关 API

所有用户 API 都在 `/api/v1/users` 路径下：

1. **创建用户**
   ```bash
   POST /api/v1/users
   Content-Type: application/json
   
   {
     "name": "张三",
     "email": "zhangsan@example.com",
     "age": 25
   }
   ```

2. **获取所有用户**
   ```bash
   GET /api/v1/users
   ```

3. **获取单个用户**
   ```bash
   GET /api/v1/users/:id
   ```

4. **更新用户**
   ```bash
   PUT /api/v1/users/:id
   Content-Type: application/json
   
   {
     "name": "张三（已更新）",
     "age": 26
   }
   ```

5. **删除用户**
   ```bash
   DELETE /api/v1/users/:id
   ```

## 数据库配置

在 `internal/config/config.yaml` 中配置：

```yaml
database:
  driver: "sqlite3"  # 数据库驱动
  dsn: "./data/app.db"  # SQLite 文件路径
```

数据库文件会自动创建在 `./data/app.db`。

## 启动服务器

```bash
# 方式1：直接运行
go run main.go server

# 方式2：编译后运行
go build -o bin/server.exe ./cmd/server
./bin/server.exe server
```

## 测试 API

### 使用 curl（Linux/Mac）

```bash
# 创建用户
curl -X POST http://localhost:8080/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{
    "name": "张三",
    "email": "zhangsan@example.com",
    "age": 25
  }'

# 获取所有用户
curl -X GET http://localhost:8080/api/v1/users

# 获取单个用户
curl -X GET http://localhost:8080/api/v1/users/1

# 更新用户
curl -X PUT http://localhost:8080/api/v1/users/1 \
  -H "Content-Type: application/json" \
  -d '{
    "name": "张三（已更新）",
    "age": 26
  }'

# 删除用户
curl -X DELETE http://localhost:8080/api/v1/users/1
```

### 使用 PowerShell（Windows）

```powershell
# 创建用户
$body = @{
    name = "张三"
    email = "zhangsan@example.com"
    age = 25
} | ConvertTo-Json

Invoke-RestMethod -Uri "http://localhost:8080/api/v1/users" -Method POST -Body $body -ContentType "application/json"

# 获取所有用户
Invoke-RestMethod -Uri "http://localhost:8080/api/v1/users" -Method GET
```

### 使用测试脚本

```bash
# Linux/Mac
chmod +x test_api.sh
./test_api.sh

# Windows PowerShell
.\test_api.ps1
```

## 代码示例

### Handler 层（控制器）

```go
// internal/api/handlers/user.go
func (h *UserHandler) CreateUser() gin.HandlerFunc {
    return func(c *gin.Context) {
        var req models.CreateUserRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.Error(err)
            return
        }

        user, err := h.userService.CreateUser(c.Request.Context(), &req)
        if err != nil {
            c.Error(err)
            return
        }

        c.JSON(http.StatusCreated, gin.H{
            "code":    200,
            "message": "创建成功",
            "data":    user,
        })
    }
}
```

### Service 层（业务逻辑）

```go
// internal/service/user_service.go
func (s *userService) CreateUser(ctx context.Context, req *models.CreateUserRequest) (*models.User, error) {
    // 业务逻辑：检查邮箱是否已存在
    _, err := s.userRepo.FindByEmail(ctx, req.Email)
    if err == nil {
        return nil, errors.NewBadRequestError("邮箱已被使用", fmt.Errorf("email already exists: %s", req.Email))
    }

    // 创建用户
    user := &models.User{
        Name:  req.Name,
        Email: req.Email,
        Age:   req.Age,
    }

    return s.userRepo.Create(ctx, user)
}
```

### Repository 层（数据访问）

```go
// internal/repository/user_repository.go
func (r *userRepository) Create(ctx context.Context, user *models.User) (*models.User, error) {
    now := time.Now()
    user.CreatedAt = now
    user.UpdatedAt = now

    result, err := r.db.Exec(
        "INSERT INTO users (name, email, age, created_at, updated_at) VALUES (?, ?, ?, ?, ?)",
        user.Name, user.Email, user.Age, user.CreatedAt, user.UpdatedAt,
    )
    if err != nil {
        return nil, fmt.Errorf("创建用户失败: %w", err)
    }

    id, err := result.LastInsertId()
    if err != nil {
        return nil, fmt.Errorf("获取用户ID失败: %w", err)
    }

    return r.FindByID(ctx, id)
}
```

## 错误处理

所有错误都通过统一的错误处理中间件处理，返回格式：

```json
{
  "error": "错误消息"
}
```

错误类型：
- `400 Bad Request` - 请求参数错误
- `404 Not Found` - 资源不存在
- `500 Internal Server Error` - 服务器内部错误

## 数据库表结构

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    age INTEGER NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

## 注意事项

1. **数据库文件位置**：SQLite 数据库文件会创建在 `./data/app.db`
2. **自动初始化**：首次启动时会自动创建表结构
3. **数据持久化**：SQLite 是文件数据库，数据会持久化保存
4. **并发安全**：SQLite 支持并发读取，但写入会加锁
