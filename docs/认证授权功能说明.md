# 认证授权功能说明

## 概述

项目已实现基于JWT的认证授权功能，采用中间件方式在请求到达接口层之前进行身份验证，确保系统资源的安全访问。

## 实现方案

### 技术栈

- **JWT (JSON Web Token)**：用于无状态认证
- **bcrypt**：用于密码哈希和验证
- **Gin中间件**：用于请求拦截和认证检查

### 核心组件

| 组件 | 路径 | 功能 |
|------|------|------|
| JWT工具 | `internal/auth/jwt.go` | JWT令牌的生成和验证 |
| 密码工具 | `internal/auth/password.go` | 密码的哈希和验证 |
| 认证中间件 | `internal/api/middleware/auth.go` | 请求认证检查 |
| 用户服务 | `internal/service/user_service.go` | 用户登录和注册逻辑 |
| 错误处理 | `internal/errors/errors.go` | 认证相关错误处理 |

## 数据库设计

### 用户表结构

```sql
CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    password TEXT NOT NULL,  -- 存储bcrypt哈希后的密码
    age INTEGER,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL
);
```

## 认证流程

### 1. 用户注册

1. 用户提交注册信息（包含密码）
2. 系统使用bcrypt算法对密码进行哈希处理
3. 哈希后的密码与其他用户信息一起存储到数据库

### 2. 用户登录

1. 用户提交邮箱和密码
2. 系统验证邮箱和密码（使用bcrypt验证哈希密码）
3. 验证成功后生成**访问令牌（Access Token）**和**刷新令牌（Refresh Token）**返回给用户
   - **访问令牌**：短期有效（默认24小时），用于访问受保护资源
   - **刷新令牌**：长期有效（默认7天），用于获取新的访问令牌

### 3. 刷新访问令牌

1. 当访问令牌过期时，用户可以使用刷新令牌获取新的访问令牌
2. 用户提交刷新令牌到刷新接口
3. 系统验证刷新令牌有效性
4. 验证成功后生成新的访问令牌返回给用户

### 4. 访问受保护资源

1. 用户在请求头中携带JWT令牌：`Authorization: Bearer {token}`
2. 认证中间件拦截请求，提取并验证令牌
3. 验证成功后将用户信息存储在请求上下文中，继续处理请求
4. 验证失败返回401未授权错误

## API接口

### 1. 用户登录

```
POST /api/v1/auth/login
Content-Type: application/json
```

**请求体：**

```json
{
  "email": "user@example.com",
  "password": "123456"
}
```

**响应：**

```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user": {
      "id": 1,
      "name": "测试用户",
      "email": "user@example.com",
      "age": 25,
      "created_at": "2026-01-17T10:00:00Z",
      "updated_at": "2026-01-17T10:00:00Z"
    }
  },
  "timestamp": 1768662000,
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

### 2. 刷新访问令牌

```
POST /api/v1/auth/refresh
Content-Type: application/json
```

**请求体：**

```json
{
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**响应：**

```json
{
  "code": 200,
  "message": "令牌刷新成功",
  "data": {
    "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  },
  "timestamp": 1768662000,
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

### 3. 用户注册

```
POST /api/v1/users
Content-Type: application/json
Authorization: Bearer {token}
```

**请求体：**

```json
{
  "name": "测试用户",
  "email": "user@example.com",
  "password": "123456",
  "age": 25
}
```

**响应：**

```json
{
  "code": 201,
  "message": "创建成功",
  "data": {
    "id": 1,
    "name": "测试用户",
    "email": "user@example.com",
    "age": 25,
    "created_at": "2026-01-17T10:00:00Z",
    "updated_at": "2026-01-17T10:00:00Z"
  },
  "timestamp": 1768662000,
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

## 使用方式

### 在路由中配置

```go
// 认证路由（不需要认证）
auth := apiGroup.Group("/auth")
{
    auth.POST("/register", userHandler.Register())   // POST /api/v1/auth/register
    auth.POST("/login", userHandler.Login())         // POST /api/v1/auth/login
    auth.POST("/refresh", userHandler.RefreshToken()) // POST /api/v1/auth/refresh
}

// 用户相关路由（需要认证）
users := apiGroup.Group("/users")
users.Use(middleware.NewAuthMiddleware()) // 应用认证中间件
{
    users.POST("", userHandler.CreateUser())       // POST /api/v1/users
    users.GET("", userHandler.GetAllUsers())       // GET /api/v1/users
    users.GET("/:id", userHandler.GetUser())       // GET /api/v1/users/:id
    users.PUT("/:id", userHandler.UpdateUser())    // PUT /api/v1/users/:id
    users.DELETE("/:id", userHandler.DeleteUser()) // DELETE /api/v1/users/:id
}
```

### 在中间件中获取用户信息

```go
// 在处理器中获取用户信息
userID, _ := c.Get("user_id")
email, _ := c.Get("email")
name, _ := c.Get("name")
```

## 配置说明

### JWT配置

JWT配置在`config.yaml`文件中：

```yaml
jwt:
  secret_key: "your-secret-key-change-in-production"  # JWT签名密钥
  expires_in: 24                                      # 访问令牌过期时间（小时）
  refresh_expires_in: 168                             # 刷新令牌过期时间（小时，默认7天）
```

## 安全特性

### 1. 密码安全

- 使用bcrypt算法进行密码哈希
- 哈希时自动生成盐值
- 支持自定义工作因子（默认10）

```go
// 哈希密码
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), 10)
    return string(bytes), err
}

// 验证密码
func CheckPassword(hashedPassword, password string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    return err == nil
}
```

### 2. JWT安全

- 令牌包含用户信息（ID、邮箱、名称）
- 令牌有过期时间限制
- 使用密钥进行签名，防止篡改

```go
// 生成令牌
func (j *JWTConfig) GenerateToken(userID int64, email, name string) (string, error) {
    claims := UserClaims{
        UserID: userID,
        Email:  email,
        Name:   name,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(j.ExpiresIn)),
        },
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.SecretKey))
}
```

### 3. 刷新令牌机制

刷新令牌机制是一个重要的安全特性，它提供了访问令牌的自动续期能力，既保证了安全性，又提升了用户体验。

#### 刷新令牌的作用

1. **提升安全性**
   - **访问令牌短期有效**：访问令牌过期时间较短（默认24小时），即使泄露，影响范围也有限
   - **刷新令牌长期有效**：刷新令牌过期时间较长（默认7天），用于获取新的访问令牌
   - **降低泄露风险**：访问令牌过期后，攻击者无法继续使用，必须持有有效的刷新令牌才能获取新的访问令牌

2. **改善用户体验**
   - **无需频繁登录**：访问令牌过期后，用户不需要重新输入用户名和密码
   - **自动续期**：通过刷新令牌自动获取新的访问令牌，用户可以长时间保持登录状态
   - **无感知刷新**：前端可以在访问令牌即将过期时自动刷新，用户无感知

3. **灵活性**
   - **独立控制**：访问令牌和刷新令牌可以独立控制过期时间
   - **精细化管理**：可以根据业务需求调整两种令牌的过期时间
   - **无状态设计**：刷新令牌也采用JWT格式，无需存储，保持无状态架构

#### 刷新令牌工作流程

```
1. 用户登录
   └─> 返回 access_token (24小时) + refresh_token (7天)

2. 使用 access_token 访问受保护资源
   ├─> 有效 → 访问成功
   └─> 过期 → 返回401

3. access_token 过期后
   └─> 使用 refresh_token 刷新
       ├─> 有效 → 返回新的 access_token
       └─> 过期 → 返回401，需要重新登录
```

#### 实现细节

**登录时生成两种令牌：**

```go
// 生成访问令牌（短期有效）
accessToken, err := jwtConfig.GenerateToken(user.ID, user.Email, user.Name)

// 生成刷新令牌（长期有效）
refreshExpiresIn := 7 * 24 * time.Hour // 7天
refreshToken, err := jwtConfig.GenerateRefreshToken(user.ID, user.Email, user.Name, refreshExpiresIn)
```

**刷新访问令牌：**

```go
// 解析刷新令牌
claims, err := jwtConfig.ParseToken(req.RefreshToken)
if err != nil {
    return nil, errors.NewUnauthorizedError("无效的刷新令牌", err)
}

// 生成新的访问令牌
accessToken, err := jwtConfig.GenerateToken(claims.UserID, claims.Email, claims.Name)
```

#### 最佳实践

1. **访问令牌过期时间**：建议设置为1-24小时，根据业务需求调整
2. **刷新令牌过期时间**：建议设置为7-30天，根据用户体验需求调整
3. **前端实现**：
   - 在访问令牌即将过期前自动刷新（如：过期前5分钟）
   - 刷新失败时引导用户重新登录
   - 将刷新令牌存储在安全的位置（如HttpOnly Cookie或安全存储）
4. **后端实现**：
   - 刷新令牌接口不需要认证（公开接口）
   - 验证刷新令牌的有效性
   - 刷新成功后返回新的访问令牌（不返回新的刷新令牌，除非需要）

### 4. 认证中间件

- 检查请求头中的Authorization字段
- 验证令牌的格式和有效性
- 验证失败返回401未授权错误

```go
// AuthMiddleware 认证中间件
func AuthMiddleware(jwtConfig *auth.JWTConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 从请求头获取Authorization
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.Error(errors.NewUnauthorizedError("未提供认证令牌", nil))
            c.Abort()
            return
        }

        // 提取Bearer令牌
        parts := strings.SplitN(authHeader, " ", 2)
        if !(len(parts) == 2 && parts[0] == "Bearer") {
            c.Error(errors.NewUnauthorizedError("认证令牌格式错误", nil))
            c.Abort()
            return
        }

        tokenString := parts[1]

        // 验证令牌
        claims, err := jwtConfig.ParseToken(tokenString)
        if err != nil {
            c.Error(errors.NewUnauthorizedError("无效的认证令牌", nil))
            c.Abort()
            return
        }

        // 将用户信息存储在请求上下文中
        c.Set("user_id", claims.UserID)
        c.Set("email", claims.Email)
        c.Set("name", claims.Name)

        c.Next()
    }
}
```

## 错误处理

### 认证相关错误

| 错误类型 | 状态码 | 错误信息 |
|----------|--------|----------|
| 未提供令牌 | 401 | "未提供认证令牌" |
| 令牌格式错误 | 401 | "认证令牌格式错误" |
| 无效令牌 | 401 | "无效的认证令牌" |
| 邮箱或密码错误 | 401 | "邮箱或密码错误" |

### 错误使用示例

```go
// 在服务层返回认证错误
if !auth.CheckPassword(user.Password, req.Password) {
    return nil, errors.NewUnauthorizedError("邮箱或密码错误", fmt.Errorf("invalid email or password"))
}

// 在中间件中返回认证错误
c.Error(errors.NewUnauthorizedError("无效的认证令牌", nil))
c.Abort()
return
```

## API文档

认证授权功能已集成到Swagger文档中，可通过以下地址访问：

```
http://localhost:8080/swagger/index.html
```

### 生成最新文档

```bash
go run github.com/swaggo/swag/cmd/swag init -o internal/docs
```

## 测试

### 1. 测试登录

#### Linux/macOS (curl)

```bash
curl -X POST -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"123456"}' http://localhost:8080/api/v1/auth/login
```

#### Windows (PowerShell)

```powershell
Invoke-WebRequest -Uri http://localhost:8080/api/v1/auth/login -Method POST -Headers @{"Content-Type"="application/json"} -Body '{"email":"test@example.com","password":"123456"}'
```

**期待结果：**
- 状态码：200 OK
- 响应内容：
  ```json
  {
    "code": 200,
    "message": "登录成功",
    "data": {
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "user": {
        "id": 1,
        "name": "测试用户",
        "email": "test@example.com",
        "age": 25,
        "created_at": "2026-01-17T10:00:00Z",
        "updated_at": "2026-01-17T10:00:00Z"
      }
    },
    "timestamp": 1768662000,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

### 2. 测试受保护资源

#### Linux/macOS (curl)

```bash
curl -H "Authorization: Bearer {token}" http://localhost:8080/api/v1/users
```

#### Windows (PowerShell)

```powershell
Invoke-WebRequest -Uri http://localhost:8080/api/v1/users -Headers @{"Authorization"="Bearer {token}"} -Method GET
```

**期待结果：**
- 状态码：200 OK
- 响应内容：
  ```json
  {
    "code": 200,
    "message": "获取成功",
    "data": [
      {
        "id": 1,
        "name": "测试用户",
        "email": "test@example.com",
        "age": 25,
        "created_at": "2026-01-17T10:00:00Z",
        "updated_at": "2026-01-17T10:00:00Z"
      }
    ],
    "timestamp": 1768662000,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

### 3. 测试未提供认证令牌访问受保护资源

#### Linux/macOS (curl)

```bash
curl -X GET http://localhost:8080/api/v1/users
```

#### Windows (PowerShell)

```powershell
Invoke-WebRequest -Uri http://localhost:8080/api/v1/users -Method GET
```

**期待结果：**
- 状态码：401 Unauthorized
- 响应内容：
  ```json
  {
    "code": 401,
    "message": "未提供认证令牌",
    "error": "未提供认证令牌",
    "timestamp": 1768662000,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

### 4. 测试提供无效认证令牌访问受保护资源

#### Linux/macOS (curl)

```bash
curl -H "Authorization: Bearer invalid-token" http://localhost:8080/api/v1/users
```

#### Windows (PowerShell)

```powershell
Invoke-WebRequest -Uri http://localhost:8080/api/v1/users -Headers @{"Authorization"="Bearer invalid-token"} -Method GET
```

**期待结果：**
- 状态码：401 Unauthorized
- 响应内容：
  ```json
  {
    "code": 401,
    "message": "无效的认证令牌",
    "error": "无效的认证令牌",
    "timestamp": 1768662000,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

### 5. 测试用户注册

#### Linux/macOS (curl)

```bash
curl -X POST -H "Content-Type: application/json" -H "Authorization: Bearer {token}" -d '{"name":"新用户","email":"new@example.com","password":"123456","age":30}' http://localhost:8080/api/v1/users
```

#### Windows (PowerShell)

```powershell
Invoke-WebRequest -Uri http://localhost:8080/api/v1/users -Method POST -Headers @{"Content-Type"="application/json";"Authorization"="Bearer {token}"} -Body '{"name":"新用户","email":"new@example.com","password":"123456","age":30}'
```

**期待结果：**
- 状态码：201 Created
- 响应内容：
  ```json
  {
    "code": 201,
    "message": "创建成功",
    "data": {
      "id": 2,
      "name": "新用户",
      "email": "new@example.com",
      "age": 30,
      "created_at": "2026-01-17T10:00:00Z",
      "updated_at": "2026-01-17T10:00:00Z"
    },
    "timestamp": 1768662000,
    "request_id": "550e8400-e29b-41d4-a716-446655440000"
  }
  ```

## 最佳实践

### 1. 令牌管理

- 将JWT令牌存储在安全的地方（如HttpOnly Cookie）
- 令牌过期后使用刷新令牌机制获取新令牌
- 敏感操作使用额外的认证方式（如二次验证）

### 2. 密码策略

- 强制使用强密码（长度、复杂度要求）
- 定期要求用户更新密码
- 限制登录失败次数，防止暴力破解

### 3. 安全配置

- 定期更换JWT密钥
- 使用HTTPS协议传输令牌
- 限制令牌的使用范围（如IP、设备）

## 注意事项

1. **令牌过期**：令牌过期后需要重新登录获取新令牌
2. **密钥安全**：JWT密钥应妥善保管，避免泄露
3. **密码更新**：用户修改密码后，所有已颁发的令牌应失效
4. **权限控制**：认证只验证身份，权限控制需要额外实现
5. **日志记录**：记录认证相关的关键操作和错误

## 任务执行问题与排查

### 端口占用问题

在实现认证授权功能时，遇到了端口8080被占用导致服务器启动失败的问题：

#### 问题现象
```
监听错误 :8080: listen tcp :8080: bind: Only one usage of each socket address (protocol/network address/port) is normally permitted.
```

#### 排查步骤

1. **查看端口占用情况**
   ```powershell
   netstat -ano | findstr :8080
   ```

2. **终止占用端口的进程**
   ```powershell
   Taskkill /PID 7048 /F
   ```

3. **重新启动服务器**
   ```powershell
   go run main.go server
   ```

## 相关文档

- [常见问题排查指南](../troubleshooting/常见问题排查指南.md)：包含更多跨平台的问题排查命令和思路

## 与其他功能集成

### 统一响应格式

认证相关API遵循项目的统一响应格式：

```json
// 成功响应
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "jwt-token",
    "user": { ... }
  },
  "timestamp": 1768662000,
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}

// 错误响应
{
  "code": 401,
  "message": "未提供认证令牌",
  "error": "未提供认证令牌",
  "timestamp": 1768662000,
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

### 错误中间件

认证错误由统一的错误中间件处理，确保响应格式一致：

```go
// ErrorHandler 统一错误处理中间件
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        // 如果已经写入响应，不再处理
        if c.Writer.Written() {
            return
        }

        // 处理最后一个错误
        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            var appErr *AppError

            if errors.As(err, &appErr) {
                // 使用统一响应格式
                respondError(c, appErr)
            } else {
                // 对于未处理的错误，返回500
                respondError(c, NewInternalServerError("内部服务器错误", err))
            }
        }
    }
}
```

## 测试问题与解决方案

在Swagger中测试认证授权功能时，遇到了以下问题，并成功解决：

### 1. Swagger中JWT令牌无法正确传递到后端

#### 问题现象
在Swagger的Authorize功能中添加了Bearer令牌，但访问受保护资源时仍然返回401错误，服务器日志显示Authorization头为空。

#### 原因分析
Swagger生成的API文档中，受保护的路由没有添加`@Security ApiKeyAuth`标签，导致Swagger不知道需要将令牌添加到请求头中。

#### 解决方案
1. 为所有需要认证的API端点添加`@Security ApiKeyAuth`标签
2. 更新所有相关的用户API端点的Swagger注释
3. 重新生成Swagger文档

```go
// 更新前
// @Router /api/v1/users [post]

// 更新后
// @Security ApiKeyAuth
// @Router /api/v1/users [post]
```

### 2. 参数验证错误返回500而不是400

#### 问题现象
当提交无效的邮箱格式（如`invalid-email`）时，API返回500 Internal Server Error，而不是预期的400 Bad Request。

#### 原因分析
错误处理中间件没有识别`validator.ValidationErrors`类型的错误，将其作为未处理的错误返回了500状态码。

#### 解决方案
修改错误处理中间件，添加对`validator.ValidationErrors`类型错误的识别和处理：

```go
// 添加validator包导入
import "github.com/go-playground/validator/v10"

// 修改错误处理中间件
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        if c.Writer.Written() {
            return
        }

        if len(c.Errors) > 0 {
            err := c.Errors.Last().Err
            var appErr *AppError

            if errors.As(err, &appErr) {
                respondError(c, appErr)
            } else if _, ok := err.(validator.ValidationErrors); ok {
                // 处理参数验证错误，返回400
                respondError(c, NewBadRequestError("请求参数错误", err))
            } else {
                respondError(c, NewInternalServerError("内部服务器错误", err))
            }
        }
    }
}
```

## 总结

本项目的认证授权功能采用了业界成熟的JWT+bcrypt方案，实现了安全、高效的用户认证系统。通过中间件的方式集成到路由中，使代码结构清晰，易于维护和扩展。同时，系统遵循了安全最佳实践，确保用户信息和系统资源的安全。在测试过程中，解决了Swagger令牌传递和参数验证错误处理的问题，使系统更加完善和健壮。